/* Generated by Frama-C */
struct __anonstruct___mpz_struct_1 {
   int _mp_alloc ;
   int _mp_size ;
   unsigned long *_mp_d ;
};
typedef struct __anonstruct___mpz_struct_1 __mpz_struct;
typedef __mpz_struct ( __attribute__((__FC_BUILTIN__)) mpz_t)[1];
typedef unsigned int size_t;
struct data_type {
   int age ;
   char name[20] ;
};
typedef struct data_type data;
/*@ requires predicate ≢ 0;
    assigns \nothing; */
extern  __attribute__((__FC_BUILTIN__)) void e_acsl_assert(int predicate,
                                                           char *kind,
                                                           char *fct,
                                                           char *pred_txt,
                                                           int line);

/*@
model __mpz_struct { ℤ n };
*/
int __fc_random_counter __attribute__((__unused__));
unsigned long const __fc_rand_max = (unsigned long)32767;
/*@ ghost extern int __fc_heap_status; */

/*@
axiomatic
  dynamic_allocation {
  predicate is_allocable{L}(size_t n) 
    reads __fc_heap_status;
  
  }
 */
/*@ assigns __fc_heap_status;
    assigns __fc_heap_status \from size, __fc_heap_status;
    assigns \result \from size, __fc_heap_status;
    allocates \result;
    
    behavior allocation:
      assumes is_allocable(size);
      ensures \fresh{Old, Here}(\result,\old(size));
      assigns __fc_heap_status;
      assigns __fc_heap_status \from size, __fc_heap_status;
      assigns \result \from size, __fc_heap_status;
    
    behavior no_allocation:
      assumes ¬is_allocable(size);
      ensures \result ≡ \null;
      assigns \result \from \nothing;
      allocates \nothing;
    
    complete behaviors no_allocation, allocation;
    disjoint behaviors no_allocation, allocation;
 */
extern  __attribute__((__nothrow__)) void *__malloc(size_t size) __attribute__((
__malloc__, __leaf__));

/*@ assigns \result \from *((char *)ptr+(0..size-1)); */
extern  __attribute__((__FC_BUILTIN__)) void *__store_block(void *ptr,
                                                            size_t size);

/*@ assigns \nothing; */
extern  __attribute__((__FC_BUILTIN__)) void __delete_block(void *ptr);

/*@ assigns \nothing; */
extern  __attribute__((__FC_BUILTIN__)) void __initialize(void *ptr,
                                                          size_t size);

/*@ assigns \nothing; */
extern  __attribute__((__FC_BUILTIN__)) void __full_init(void *ptr);

/*@ assigns \nothing; */
extern  __attribute__((__FC_BUILTIN__)) void __literal_string(void *ptr);

/*@ ensures \result ≡ 0 ∨ \result ≡ 1;
    ensures \result ≡ 1 ⇒ \valid((char *)\old(ptr)+(0..\old(size)-1));
    assigns \result \from *((char *)ptr+(0..size-1));
 */
extern  __attribute__((__FC_BUILTIN__)) int __valid(void *ptr, size_t size);

/*@ ensures \result ≡ 0 ∨ \result ≡ 1;
    ensures
      \result ≡ 1 ⇒ \valid_read((char *)\old(ptr)+(0..\old(size)-1));
    assigns \result \from *((char *)ptr+(0..size-1));
 */
extern  __attribute__((__FC_BUILTIN__)) int __valid_read(void *ptr,
                                                         size_t size);

/*@ assigns __e_acsl_internal_heap;
    assigns __e_acsl_internal_heap \from __e_acsl_internal_heap;
 */
extern  __attribute__((__FC_BUILTIN__)) void __e_acsl_memory_clean(void);

extern size_t __memory_size;

/*@ assigns __fc_heap_status;
    assigns __fc_heap_status \from size, __fc_heap_status;
    assigns \result \from size, __fc_heap_status;
    allocates \result;
    
    behavior allocation:
      assumes is_allocable(size);
      ensures \fresh{Old, Here}(\result,\old(size));
      assigns __fc_heap_status;
      assigns __fc_heap_status \from size, __fc_heap_status;
      assigns \result \from size, __fc_heap_status;
    
    behavior no_allocation:
      assumes ¬is_allocable(size);
      ensures \result ≡ \null;
      assigns \result \from \nothing;
      allocates \nothing;
    
    complete behaviors no_allocation, allocation;
    disjoint behaviors no_allocation, allocation;
 */
void *__e_acsl_malloc(size_t size)
{
  void *__retres;
  __store_block((void *)(& __retres),4U);
  __retres = __malloc(size);
  __delete_block((void *)(& __retres));
  return __retres;
}

/*@
predicate diffSize{L1, L2}(ℤ i) =
  \at(__memory_size,L1)-\at(__memory_size,L2) ≡ i;

*/
/*@ assigns \at(\result,Post) \from *__format; */
extern int printf(char const * __restrict __format , ...);

/*@ assigns *__dest;
    assigns \at(\result,Post) \from *__dest, *__src;
    assigns *__dest \from *__dest, *__src;
 */
extern  __attribute__((__nothrow__)) char *strcpy(char * __restrict __dest,
                                                  char const * __restrict __src) __attribute__((
__nonnull__(1,2), __leaf__));

/*@ assigns \at(\result,Post) \from *__s; */
extern  __attribute__((__nothrow__)) size_t strlen(char const *__s) __attribute__((
__pure__, __nonnull__(1), __leaf__));

void func1(char *p)
{
  char *__e_acsl_literal_string_2;
  char *__e_acsl_literal_string;
  size_t tmp;
  tmp = strlen((char const *)p);
  __e_acsl_literal_string = "the length of func1 is %d\n";
  __store_block((void *)__e_acsl_literal_string,
                sizeof("the length of func1 is %d\n"));
  __full_init((void *)__e_acsl_literal_string);
  __literal_string((void *)__e_acsl_literal_string);
  printf(__e_acsl_literal_string,tmp);
  /*@ assert rte: mem_access: \valid_read(p+4); */
  {
    int __e_acsl_valid_read;
    __e_acsl_valid_read = __valid_read((void *)(p + 4),sizeof(char));
    e_acsl_assert(__e_acsl_valid_read,(char *)"Assertion",(char *)"func1",
                  (char *)"rte: mem_access: \\valid_read(p+4)",25);
  }
  __e_acsl_literal_string_2 = "%c\n";
  __store_block((void *)__e_acsl_literal_string_2,sizeof("%c\n"));
  __full_init((void *)__e_acsl_literal_string_2);
  __literal_string((void *)__e_acsl_literal_string_2);
  printf(__e_acsl_literal_string_2,*(p + 4));
  return;
}

void func2(data **p)
{
  char *__e_acsl_literal_string;
  /*@ assert rte: mem_access: \valid_read(p+0); */
  {
    int __e_acsl_valid_read;
    __store_block((void *)(& p),4U);
    __e_acsl_valid_read = __valid_read((void *)(p + 0),sizeof(data *));
    e_acsl_assert(__e_acsl_valid_read,(char *)"Assertion",(char *)"func2",
                  (char *)"rte: mem_access: \\valid_read(p+0)",32);
  }
  /*@ assert rte: mem_access: \valid_read(p+0); */
  {
    int __e_acsl_valid_read_2;
    __e_acsl_valid_read_2 = __valid_read((void *)(p + 0),sizeof(data *));
    e_acsl_assert(__e_acsl_valid_read_2,(char *)"Assertion",(char *)"func2",
                  (char *)"rte: mem_access: \\valid_read(p+0)",33);
  }
  /*@ assert rte: mem_access: \valid_read(&(*(p+0))->age); */
  {
    int __e_acsl_valid_read_3;
    int __e_acsl_valid_read_4;
    __e_acsl_valid_read_3 = __valid_read((void *)(p + 0),sizeof(data *));
    e_acsl_assert(__e_acsl_valid_read_3,(char *)"RTE",(char *)"func2",
                  (char *)"mem_access: \\valid_read(p+0)",34);
    __e_acsl_valid_read_4 = __valid_read((void *)(& (*(p + 0))->age),
                                         sizeof(int));
    e_acsl_assert(__e_acsl_valid_read_4,(char *)"Assertion",(char *)"func2",
                  (char *)"rte: mem_access: \\valid_read(&(*(p+0))->age)",34);
  }
  __e_acsl_literal_string = "%s is %d years old\n";
  __store_block((void *)__e_acsl_literal_string,
                sizeof("%s is %d years old\n"));
  __full_init((void *)__e_acsl_literal_string);
  __literal_string((void *)__e_acsl_literal_string);
  printf(__e_acsl_literal_string,(*(p + 0))->name,(*(p + 0))->age);
  __delete_block((void *)(& p));
  return;
}

void func4(data *p)
{
  char *__e_acsl_literal_string;
  /*@ assert rte: mem_access: \valid_read(&p->age); */
  {
    int __e_acsl_valid_read;
    __store_block((void *)(& p),4U);
    __e_acsl_valid_read = __valid_read((void *)(& p->age),sizeof(int));
    e_acsl_assert(__e_acsl_valid_read,(char *)"Assertion",(char *)"func4",
                  (char *)"rte: mem_access: \\valid_read(&p->age)",41);
  }
  __e_acsl_literal_string = "%s is %d years old\n";
  __store_block((void *)__e_acsl_literal_string,
                sizeof("%s is %d years old\n"));
  __full_init((void *)__e_acsl_literal_string);
  __literal_string((void *)__e_acsl_literal_string);
  printf(__e_acsl_literal_string,p->name,p->age);
  __delete_block((void *)(& p));
  return;
}

void func3(char *p1, char *p2)
{
  char *__e_acsl_literal_string_3;
  char *__e_acsl_literal_string_2;
  char *__e_acsl_literal_string;
  size_t tmp;
  size_t tmp_0;
  tmp = strlen((char const *)p1);
  __e_acsl_literal_string = "the length of func3 is %d\n";
  __store_block((void *)__e_acsl_literal_string,
                sizeof("the length of func3 is %d\n"));
  __full_init((void *)__e_acsl_literal_string);
  __literal_string((void *)__e_acsl_literal_string);
  printf(__e_acsl_literal_string,tmp);
  strcpy(p1,(char const *)p2);
  tmp_0 = strlen((char const *)p2);
  __e_acsl_literal_string_2 = "the length of func3 is %d\n";
  __store_block((void *)__e_acsl_literal_string_2,
                sizeof("the length of func3 is %d\n"));
  __full_init((void *)__e_acsl_literal_string_2);
  __literal_string((void *)__e_acsl_literal_string_2);
  printf(__e_acsl_literal_string_2,tmp_0);
  __e_acsl_literal_string_3 = "the string is %s\n";
  __store_block((void *)__e_acsl_literal_string_3,
                sizeof("the string is %s\n"));
  __full_init((void *)__e_acsl_literal_string_3);
  __literal_string((void *)__e_acsl_literal_string_3);
  printf(__e_acsl_literal_string_3,p1);
  return;
}

int main(void)
{
  char *__e_acsl_literal_string_3;
  char *__e_acsl_literal_string_2;
  char *__e_acsl_literal_string;
  int __retres;
  int i;
  data *bob[100];
  data *bob1;
  char string[8];
  char *a;
  char *p1;
  char *p2;
  char *p3;
  __store_block((void *)(& p1),4U);
  __store_block((void *)(& a),4U);
  __store_block((void *)(string),8U);
  __store_block((void *)(& bob1),4U);
  __store_block((void *)(bob),400U);
  __initialize((void *)(string),sizeof(char));
  string[0] = (char)'A';
  __initialize((void *)(& string[1]),sizeof(char));
  string[1] = (char)'S';
  __initialize((void *)(& string[2]),sizeof(char));
  string[2] = (char)'D';
  __initialize((void *)(& string[3]),sizeof(char));
  string[3] = (char)'E';
  __initialize((void *)(& string[4]),sizeof(char));
  string[4] = (char)'S';
  __initialize((void *)(& string[5]),sizeof(char));
  string[5] = (char)'F';
  __initialize((void *)(& string[6]),sizeof(char));
  string[6] = (char)'P';
  __initialize((void *)(& string[7]),sizeof(char));
  string[7] = (char)'\000';
  __full_init((void *)(& a));
  a = (char *)__e_acsl_malloc((unsigned int)100 * sizeof(char));
  i = 2;
  i = 0;
  while (i < 100) {
    __full_init((void *)(& bob1));
    bob1 = (data *)__e_acsl_malloc((unsigned int)100 * sizeof(data));
    if (bob1 != (void *)0) {
      /*@ assert rte: mem_access: \valid(&bob1->age); */
      {
        int __e_acsl_valid;
        __e_acsl_valid = __valid((void *)(& bob1->age),sizeof(int));
        e_acsl_assert(__e_acsl_valid,(char *)"Assertion",(char *)"main",
                      (char *)"rte: mem_access: \\valid(&bob1->age)",84);
      }
      __initialize((void *)(& bob1->age),sizeof(int));
      bob1->age = i;
      __e_acsl_literal_string = "Robert";
      __store_block((void *)__e_acsl_literal_string,sizeof("Robert"));
      __full_init((void *)__e_acsl_literal_string);
      __literal_string((void *)__e_acsl_literal_string);
      strcpy(bob1->name,__e_acsl_literal_string);
      /*@ assert rte: index_bound: 0 ≤ i; */
      e_acsl_assert(0 <= i,(char *)"Assertion",(char *)"main",
                    (char *)"rte: index_bound: 0 <= i",87);
      /*@ assert rte: index_bound: i < 100; */
      e_acsl_assert(i < 100,(char *)"Assertion",(char *)"main",
                    (char *)"rte: index_bound: i < 100",88);
      __initialize((void *)(& bob[i]),sizeof(data *));
      bob[i] = bob1;
    }
    /*@ assert rte: signed_overflow: i+1 ≤ 2147483647; */
    e_acsl_assert((long long)i + (long long)1 <= (long long)2147483647,
                  (char *)"Assertion",(char *)"main",
                  (char *)"rte: signed_overflow: i+1 <= 2147483647",91);
    i ++;
  }
  i = 0;
  while (i < 10) {
    /*@ assert rte: index_bound: 0 ≤ i; */
    e_acsl_assert(0 <= i,(char *)"Assertion",(char *)"main",
                  (char *)"rte: index_bound: 0 <= i",96);
    /*@ assert rte: index_bound: i < 100; */
    e_acsl_assert(i < 100,(char *)"Assertion",(char *)"main",
                  (char *)"rte: index_bound: i < 100",97);
    /*@ assert rte: index_bound: 0 ≤ i; */
    e_acsl_assert(0 <= i,(char *)"Assertion",(char *)"main",
                  (char *)"rte: index_bound: 0 <= i",98);
    /*@ assert rte: index_bound: i < 100; */
    e_acsl_assert(i < 100,(char *)"Assertion",(char *)"main",
                  (char *)"rte: index_bound: i < 100",99);
    /*@ assert rte: mem_access: \valid_read(&(bob[i])->age); */
    {
      int __e_acsl_valid_read;
      e_acsl_assert(i < 100,(char *)"RTE",(char *)"main",
                    (char *)"index_bound: i < 100",100);
      e_acsl_assert(0 <= i,(char *)"RTE",(char *)"main",
                    (char *)"index_bound: 0 <= i",100);
      __e_acsl_valid_read = __valid_read((void *)(& (bob[i])->age),
                                         sizeof(int));
      e_acsl_assert(__e_acsl_valid_read,(char *)"Assertion",(char *)"main",
                    (char *)"rte: mem_access: \\valid_read(&(bob[i])->age)",
                    100);
    }
    __e_acsl_literal_string_2 = "%s %d\n";
    __store_block((void *)__e_acsl_literal_string_2,sizeof("%s %d\n"));
    __full_init((void *)__e_acsl_literal_string_2);
    __literal_string((void *)__e_acsl_literal_string_2);
    printf(__e_acsl_literal_string_2,(bob[i])->name,(bob[i])->age);
    /*@ assert rte: signed_overflow: i+1 ≤ 2147483647; */
    e_acsl_assert((long long)i + (long long)1 <= (long long)2147483647,
                  (char *)"Assertion",(char *)"main",
                  (char *)"rte: signed_overflow: i+1 <= 2147483647",102);
    i ++;
  }
  __e_acsl_literal_string_3 = "DKLRTF";
  __store_block((void *)__e_acsl_literal_string_3,sizeof("DKLRTF"));
  __full_init((void *)__e_acsl_literal_string_3);
  __literal_string((void *)__e_acsl_literal_string_3);
  p3 = (char *)__e_acsl_literal_string_3;
  __full_init((void *)(& p1));
  p1 = & string[5];
  p2 = p3;
  func2(& bob1);
  func4(bob1);
  __retres = 1;
  __delete_block((void *)(& p1));
  __delete_block((void *)(& a));
  __delete_block((void *)(string));
  __delete_block((void *)(& bob1));
  __delete_block((void *)(bob));
  __e_acsl_memory_clean();
  return __retres;
}


