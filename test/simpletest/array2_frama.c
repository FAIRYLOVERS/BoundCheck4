/* Generated by Frama-C */
struct __anonstruct___mpz_struct_1 {
   int _mp_alloc ;
   int _mp_size ;
   unsigned long *_mp_d ;
};
typedef struct __anonstruct___mpz_struct_1 __mpz_struct;
typedef __mpz_struct ( __attribute__((__FC_BUILTIN__)) mpz_t)[1];
typedef unsigned int size_t;
struct __anonstruct_s_6 {
   int u[12] ;
};
struct _s {
   int t[15] ;
   struct __anonstruct_s_6 s ;
   struct _s *next ;
};
typedef struct _s ts;
/*@ requires predicate ≢ 0;
    assigns \nothing; */
extern  __attribute__((__FC_BUILTIN__)) void e_acsl_assert(int predicate,
                                                           char *kind,
                                                           char *fct,
                                                           char *pred_txt,
                                                           int line);

/*@
model __mpz_struct { ℤ n };
*/
int __fc_random_counter __attribute__((__unused__));
unsigned long const __fc_rand_max = (unsigned long)32767;
/*@ ghost extern int __fc_heap_status; */

/*@
axiomatic
  dynamic_allocation {
  predicate is_allocable{L}(size_t n) 
    reads __fc_heap_status;
  
  }
 */
/*@ assigns \result \from *((char *)ptr+(0..size-1)); */
extern  __attribute__((__FC_BUILTIN__)) void *__store_block(void *ptr,
                                                            size_t size);

/*@ assigns \nothing; */
extern  __attribute__((__FC_BUILTIN__)) void __delete_block(void *ptr);

/*@ assigns \nothing; */
extern  __attribute__((__FC_BUILTIN__)) void __initialize(void *ptr,
                                                          size_t size);

/*@ ensures \result ≡ 0 ∨ \result ≡ 1;
    ensures \result ≡ 1 ⇒ \valid((char *)\old(ptr)+(0..\old(size)-1));
    assigns \result \from *((char *)ptr+(0..size-1));
 */
extern  __attribute__((__FC_BUILTIN__)) int __valid(void *ptr, size_t size);

/*@ assigns __e_acsl_internal_heap;
    assigns __e_acsl_internal_heap \from __e_acsl_internal_heap;
 */
extern  __attribute__((__FC_BUILTIN__)) void __e_acsl_memory_clean(void);

extern size_t __memory_size;

/*@
predicate diffSize{L1, L2}(ℤ i) =
  \at(__memory_size,L1)-\at(__memory_size,L2) ≡ i;
 */
int t[10];
int u[8 + 3];
int v[16][17];
ts s;
unsigned int c[10];
void __e_acsl_memory_init(void)
{
  __store_block((void *)(& s),112U);
  return;
}

int main(void)
{
  int __retres;
  int i;
  int j;
  unsigned int k;
  __e_acsl_memory_init();
  k = (unsigned int)1;
  j = (int)k;
  i = j;
  t[0] = 0;
  u[1] = 0;
  v[2][3] = 0;
  __initialize((void *)(& s.t[1]),sizeof(int));
  s.t[1] = 0;
  __initialize((void *)(& s.s.u[2]),sizeof(int));
  s.s.u[2] = 0;
  /*@ assert rte: mem_access: \valid(&(s.next)->t[4]); */
  {
    int __e_acsl_valid;
    __e_acsl_valid = __valid((void *)(& (s.next)->t[4]),sizeof(int));
    e_acsl_assert(__e_acsl_valid,(char *)"Assertion",(char *)"main",
                  (char *)"rte: mem_access: \\valid(&(s.next)->t[4])",36);
  }
  __initialize((void *)(& (s.next)->t[4]),sizeof(int));
  (s.next)->t[4] = 0;
  /*@ assert rte: index_bound: 0 ≤ i; */
  e_acsl_assert(0 <= i,(char *)"Assertion",(char *)"main",
                (char *)"rte: index_bound: 0 <= i",38);
  /*@ assert rte: index_bound: i < 10; */
  e_acsl_assert(i < 10,(char *)"Assertion",(char *)"main",
                (char *)"rte: index_bound: i < 10",39);
  t[i] = 0;
  /*@ assert rte: index_bound: 0 ≤ i; */
  e_acsl_assert(0 <= i,(char *)"Assertion",(char *)"main",
                (char *)"rte: index_bound: 0 <= i",41);
  /*@ assert rte: index_bound: i < (int)(8+3); */
  e_acsl_assert(i < 8 + 3,(char *)"Assertion",(char *)"main",
                (char *)"rte: index_bound: i < (int)(8+3)",42);
  u[i] = 0;
  /*@ assert rte: index_bound: 0 ≤ i; */
  e_acsl_assert(0 <= i,(char *)"Assertion",(char *)"main",
                (char *)"rte: index_bound: 0 <= i",44);
  /*@ assert rte: index_bound: i < 16; */
  e_acsl_assert(i < 16,(char *)"Assertion",(char *)"main",
                (char *)"rte: index_bound: i < 16",45);
  /*@ assert rte: index_bound: 0 ≤ j; */
  e_acsl_assert(0 <= j,(char *)"Assertion",(char *)"main",
                (char *)"rte: index_bound: 0 <= j",46);
  /*@ assert rte: index_bound: j < 17; */
  e_acsl_assert(j < 17,(char *)"Assertion",(char *)"main",
                (char *)"rte: index_bound: j < 17",47);
  v[i][j] = 0;
  /*@ assert rte: index_bound: 0 ≤ i; */
  e_acsl_assert(0 <= i,(char *)"Assertion",(char *)"main",
                (char *)"rte: index_bound: 0 <= i",49);
  /*@ assert rte: index_bound: i < 15; */
  e_acsl_assert(i < 15,(char *)"Assertion",(char *)"main",
                (char *)"rte: index_bound: i < 15",50);
  __initialize((void *)(& s.t[i]),sizeof(int));
  s.t[i] = 0;
  /*@ assert rte: index_bound: 0 ≤ i; */
  e_acsl_assert(0 <= i,(char *)"Assertion",(char *)"main",
                (char *)"rte: index_bound: 0 <= i",52);
  /*@ assert rte: index_bound: i < 12; */
  e_acsl_assert(i < 12,(char *)"Assertion",(char *)"main",
                (char *)"rte: index_bound: i < 12",53);
  __initialize((void *)(& s.s.u[i]),sizeof(int));
  s.s.u[i] = 0;
  /*@ assert rte: index_bound: 0 ≤ j; */
  e_acsl_assert(0 <= j,(char *)"Assertion",(char *)"main",
                (char *)"rte: index_bound: 0 <= j",55);
  /*@ assert rte: index_bound: j < 15; */
  e_acsl_assert(j < 15,(char *)"Assertion",(char *)"main",
                (char *)"rte: index_bound: j < 15",56);
  /*@ assert rte: mem_access: \valid(&(s.next)->t[j]); */
  {
    int __e_acsl_valid_2;
    __e_acsl_valid_2 = __valid((void *)(& (s.next)->t[j]),sizeof(int));
    e_acsl_assert(__e_acsl_valid_2,(char *)"Assertion",(char *)"main",
                  (char *)"rte: mem_access: \\valid(&(s.next)->t[j])",57);
  }
  __initialize((void *)(& (s.next)->t[j]),sizeof(int));
  (s.next)->t[j] = 0;
  /*@ assert rte: index_bound: k < 10; */
  e_acsl_assert(k < (unsigned int)10,(char *)"Assertion",(char *)"main",
                (char *)"rte: index_bound: k < 10",59);
  t[k] = 0;
  /*@ assert rte: index_bound: k < (int)(8+3); */
  e_acsl_assert(k < (unsigned int)(8 + 3),(char *)"Assertion",(char *)"main",
                (char *)"rte: index_bound: k < (int)(8+3)",61);
  u[k] = 0;
  /*@ assert rte: index_bound: k < 16; */
  e_acsl_assert(k < (unsigned int)16,(char *)"Assertion",(char *)"main",
                (char *)"rte: index_bound: k < 16",63);
  /*@ assert rte: index_bound: c[k] < 17; */
  e_acsl_assert(k < (unsigned int)10,(char *)"RTE",(char *)"main",
                (char *)"index_bound: k < 10",64);
  e_acsl_assert(c[k] < (unsigned int)17,(char *)"Assertion",(char *)"main",
                (char *)"rte: index_bound: c[k] < 17",64);
  /*@ assert rte: index_bound: k < 10; */
  e_acsl_assert(k < (unsigned int)10,(char *)"Assertion",(char *)"main",
                (char *)"rte: index_bound: k < 10",65);
  v[k][c[k]] = 0;
  /*@ assert rte: index_bound: k < 15; */
  e_acsl_assert(k < (unsigned int)15,(char *)"Assertion",(char *)"main",
                (char *)"rte: index_bound: k < 15",67);
  __initialize((void *)(& s.t[k]),sizeof(int));
  s.t[k] = 0;
  /*@ assert rte: index_bound: k < 12; */
  e_acsl_assert(k < (unsigned int)12,(char *)"Assertion",(char *)"main",
                (char *)"rte: index_bound: k < 12",69);
  __initialize((void *)(& s.s.u[k]),sizeof(int));
  s.s.u[k] = 0;
  /*@ assert rte: index_bound: c[k] < 15; */
  e_acsl_assert(k < (unsigned int)10,(char *)"RTE",(char *)"main",
                (char *)"index_bound: k < 10",71);
  e_acsl_assert(c[k] < (unsigned int)15,(char *)"Assertion",(char *)"main",
                (char *)"rte: index_bound: c[k] < 15",71);
  /*@ assert rte: mem_access: \valid(&(s.next)->t[c[k]]); */
  {
    int __e_acsl_valid_3;
    e_acsl_assert(k < (unsigned int)10,(char *)"RTE",(char *)"main",
                  (char *)"index_bound: k < 10",72);
    __e_acsl_valid_3 = __valid((void *)(& (s.next)->t[c[k]]),sizeof(int));
    e_acsl_assert(__e_acsl_valid_3,(char *)"Assertion",(char *)"main",
                  (char *)"rte: mem_access: \\valid(&(s.next)->t[c[k]])",72);
  }
  /*@ assert rte: index_bound: k < 10; */
  e_acsl_assert(k < (unsigned int)10,(char *)"Assertion",(char *)"main",
                (char *)"rte: index_bound: k < 10",73);
  __initialize((void *)(& (s.next)->t[c[k]]),sizeof(int));
  (s.next)->t[c[k]] = 0;
  /*@ assert rte: index_bound: k < 10; */
  e_acsl_assert(k < (unsigned int)10,(char *)"Assertion",(char *)"main",
                (char *)"rte: index_bound: k < 10",75);
  c[k] = (unsigned int)0;
  __retres = 0;
  __delete_block((void *)(& s));
  __e_acsl_memory_clean();
  return __retres;
}


