/* Generated by Frama-C */
struct __anonstruct___mpz_struct_1 {
   int _mp_alloc ;
   int _mp_size ;
   unsigned long *_mp_d ;
};
typedef struct __anonstruct___mpz_struct_1 __mpz_struct;
typedef __mpz_struct ( __attribute__((__FC_BUILTIN__)) mpz_t)[1];
typedef unsigned int size_t;
/*@ requires predicate ≢ 0;
    assigns \nothing; */
extern  __attribute__((__FC_BUILTIN__)) void e_acsl_assert(int predicate,
                                                           char *kind,
                                                           char *fct,
                                                           char *pred_txt,
                                                           int line);

/*@
model __mpz_struct { ℤ n };
*/
int __fc_random_counter __attribute__((__unused__));
unsigned long const __fc_rand_max = (unsigned long)32767;
/*@ ghost extern int __fc_heap_status; */

/*@
axiomatic
  dynamic_allocation {
  predicate is_allocable{L}(size_t n) 
    reads __fc_heap_status;
  
  }
 */
/*@ assigns \result \from *((char *)ptr+(0..size-1)); */
extern  __attribute__((__FC_BUILTIN__)) void *__store_block(void *ptr,
                                                            size_t size);

/*@ assigns \nothing; */
extern  __attribute__((__FC_BUILTIN__)) void __delete_block(void *ptr);

/*@ assigns \nothing; */
extern  __attribute__((__FC_BUILTIN__)) void __full_init(void *ptr);

/*@ assigns \nothing; */
extern  __attribute__((__FC_BUILTIN__)) void __literal_string(void *ptr);

/*@ ensures \result ≡ 0 ∨ \result ≡ 1;
    ensures
      \result ≡ 1 ⇒ \valid_read((char *)\old(ptr)+(0..\old(size)-1));
    assigns \result \from *((char *)ptr+(0..size-1));
 */
extern  __attribute__((__FC_BUILTIN__)) int __valid_read(void *ptr,
                                                         size_t size);

/*@ ensures \result ≡ 0 ∨ \result ≡ 1;
    ensures
      \result ≡ 1 ⇒ \initialized((char *)\old(ptr)+(0..\old(size)-1));
    assigns \result \from *((char *)ptr+(0..size-1));
 */
extern  __attribute__((__FC_BUILTIN__)) int __initialized(void *ptr,
                                                          size_t size);

/*@ assigns __e_acsl_internal_heap;
    assigns __e_acsl_internal_heap \from __e_acsl_internal_heap;
 */
extern  __attribute__((__FC_BUILTIN__)) void __e_acsl_memory_clean(void);

extern size_t __memory_size;

/*@
predicate diffSize{L1, L2}(ℤ i) =
  \at(__memory_size,L1)-\at(__memory_size,L2) ≡ i;
 */
/*@ assigns \at(\result,Post) \from __c; */
extern int putchar(int __c);

void show_string(char *string)
{
  __store_block((void *)(& string),4U);
  while (1) {
    {
      char *tmp;
      __store_block((void *)(& tmp),4U);
      /*@ assert rte: mem_access: \valid_read(string); */
      {
        int __e_acsl_valid_read;
        __e_acsl_valid_read = __valid_read((void *)string,sizeof(char));
        e_acsl_assert(__e_acsl_valid_read,(char *)"Assertion",
                      (char *)"show_string",
                      (char *)"rte: mem_access: \\valid_read(string)",8);
      }
      if (! *string) break;
      __full_init((void *)(& tmp));
      tmp = string;
      string ++;
      /*@ assert rte: mem_access: \valid_read(tmp); */
      {
        int __e_acsl_initialized;
        int __e_acsl_and;
        __e_acsl_initialized = __initialized((void *)(& tmp),sizeof(char *));
        if (__e_acsl_initialized) {
          int __e_acsl_valid_read_2;
          __e_acsl_valid_read_2 = __valid_read((void *)tmp,sizeof(char));
          __e_acsl_and = __e_acsl_valid_read_2;
        }
        else __e_acsl_and = 0;
        e_acsl_assert(__e_acsl_and,(char *)"Assertion",(char *)"show_string",
                      (char *)"rte: mem_access: \\valid_read(tmp)",16);
      }
      putchar((int)*tmp);
      __delete_block((void *)(& tmp));
    }
  }
  __delete_block((void *)(& string));
  return;
}

int main(void)
{
  char *__e_acsl_literal_string;
  int __retres;
  __e_acsl_literal_string = "Jamsa\'s 1001 C/C++ Tips";
  __store_block((void *)__e_acsl_literal_string,
                sizeof("Jamsa\'s 1001 C/C++ Tips"));
  __full_init((void *)__e_acsl_literal_string);
  __literal_string((void *)__e_acsl_literal_string);
  show_string((char *)__e_acsl_literal_string);
  __retres = 1;
  __e_acsl_memory_clean();
  return __retres;
}


